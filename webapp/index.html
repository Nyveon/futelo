<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<link rel="icon" type="image/svg+xml" href="/vite.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Futelo</title>
	</head>
	<body
		x-data="{
    user_stats: null,
    valid: true,
    letter_limits: {
        'a': 6,
        'b': 6,
        'c': 6,
        'd': 6,
        'e': 6,
        'f': 6,
        'g': 6,
        'h': 6,
        'i': 6,
        'j': 6,
        'k': 6,
        'l': 6,
        'm': 6,
        'n': 6,
        'ñ': 6,
        'o': 6,
        'p': 6,
        'q': 6,
        'r': 6,
        's': 6,
        't': 6,
        'u': 6,
        'v': 6,
        'w': 6,
        'x': 6,
        'y': 6,
        'z': 6,
        '#': 6,
        '?': 6,
    },
    LETTERS: 'abcdefghijklmnñopqrstuvwxyz#?',
    mapLetterLimits(letter_limits_list){
        this.letter_limits = {};
        for (let i = 0; i < letter_limits_list.length; i++){
            this.letter_limits[this.LETTERS[i]] = letter_limits_list[i];
        }
    },
    getUserStats(){
        var userId = new URLSearchParams(window.location.search).get('user_id');
        if ( (!userId) && (window.Telegram.WebApp.initDataUnsafe.user) ){
            userId = window.Telegram.WebApp.initDataUnsafe.user.id;
        }
        if (userId){
            // THIS URL HAS TO BE CHANGED
            fetch('https://71c8-164-92-91-99.ngrok-free.app/stats?user_id=' + userId,{
                method: 'GET',
                headers: {
                    'ngrok-skip-browser-warning': 'truuu',
                },
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error(data.error);
                    return;
                }
                this.user_stats = data;
                this.mapLetterLimits(data.letter_limits_list);
            })
            .catch(error => console.error(error));
        }
    },
    categories: {
        'a': 0,
        'b': 0,
        'c': 0,
        'd': 0,
        'e': 0,
        'f': 0,
        'g': 0,
        'h': 0,
        'i': 0,
        'j': 0,
        'k': 0,
        'l': 0,
        'm': 0,
        'n': 0,
        'ñ': 0,
        'o': 0,
        'p': 0,
        'q': 0,
        'r': 0,
        's': 0,
        't': 0,
        'u': 0,
        'v': 0,
        'w': 0,
        'x': 0,
        'y': 0,
        'z': 0,
        '#': 0,
        '?': 0,
    },
    categoryLimit(category){
        return this.letter_limits[category];
    },
    frequencyText(category, count, limit) {
        if (count > limit) {
            return `${category} | ${count.toString().padEnd(limit, ' ')}`;
        }
        const bars = '■'.repeat(count);
        const spaces = '□'.repeat(limit - count);
        return `${category} | ${bars}${spaces}`;
    },
    normalizeText(text) {
        return text.toLowerCase().replaceAll('ñ','\001').normalize('NFD').replace(/[\u0300-\u036f]/g, '').replaceAll('\001','ñ');
    },
    characterCategory(char){
        if (this.categories.hasOwnProperty(char)) {
            return char
        } else if (!isNaN(char)) {
            return '#'
            this.categories['#']++;
        } else if (/[^a-z0-9]/.test(char)) {
            return '?'
        }
    },
    checkValid(text){
        for (let char of text){
            if (this.getCharClass(char) == 'tx'){
                return false;
            }
        }
        return true;
    },
    updateCategories() {
        const originalText = this.$refs.editable.innerText
        const text = this.normalizeText(originalText);
        Object.keys(this.categories).forEach(key => this.categories[key] = 0);
        if (!text) return;
        for (let char of text) {
            if (/\s/.test(char)) continue;
            if (this.categories.hasOwnProperty(char)) {
                this.categories[char]++;
            } else if (!isNaN(char)) {
                this.categories['#']++;
            } else if (/[^a-z0-9]/.test(char)) {
                this.categories['?']++;
            }
        }

        this.applyColoredText(originalText);
        this.valid = this.checkValid(text);
    },
    getFrequencyClass(category,count) {
        if (count > this.letter_limits[category]) return 'tx';
        return `t${count}`;
    },
    getOtherFrequencyClass(category,count) {
        if (count > this.letter_limits[category]) return 'fx';
        return `f${count}`;
    },
    getCharClass(char) {
        const normalizedChar = this.normalizeText(char);

        let count = this.categories[normalizedChar] || (/\d/.test(char) ? this.categories['#'] : this.categories['?']);
        return this.getFrequencyClass(this.characterCategory(normalizedChar) , count);
    },
    applyColoredText(text) {
        const selection = window.getSelection();
        const range = selection.getRangeAt(0);
        const preCaretRange = range.cloneRange();
        preCaretRange.selectNodeContents(this.$refs.editable);
        preCaretRange.setEnd(range.startContainer, range.startOffset);
        const cursorPosition = preCaretRange.toString().length;

        let coloredHTML = '';
        for (let char of text) {
            const className = this.getCharClass(char);
            coloredHTML += `<span class='${className}'>${char}</span>`;
        }

        this.$refs.editable.innerHTML = coloredHTML;

        this.restoreCursorPosition(cursorPosition);
    },

    restoreCursorPosition(cursorPosition) {
        const selection = window.getSelection();
        const range = document.createRange();

        let charCount = 0;
        const nodes = this.$refs.editable.childNodes;

        for (let node of nodes) {
            if (node.nodeType === Node.TEXT_NODE) {
                const textLength = node.length;
                if (charCount + textLength >= cursorPosition) {
                    range.setStart(node, cursorPosition - charCount);
                    range.collapse(true);
                    break;
                }
                charCount += textLength;
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                const textLength = node.textContent.length;
                if (charCount + textLength >= cursorPosition) {
                    range.setStart(node.firstChild || node, cursorPosition - charCount);
                    range.collapse(true);
                    break;
                }
                charCount += textLength;
            }
        }
        selection.removeAllRanges();
        selection.addRange(range);
    },
    goToTelegram() {
        const text = this.$refs.editable.innerText;
        window.location.href = `https://t.me/share/url?url=${encodeURIComponent(text)}`;
    },
}"
		x-init="getUserStats"
	>
		<main>
			<h1>Futelo</h1>

			<section class="editable-section">
				<div
					contenteditable="true"
					x-ref="editable"
					@input="updateCategories"
				></div>
				<button
					style="min-height: 60px; min-width: 60px"
					x-on:click="goToTelegram()"
					x-bind:disabled="!valid"
				>
					→
				</button>
			</section>

			<section>
				<ul class="inventory">
					<template x-for="(count, category) in categories">
						<li class="item" :class="getOtherFrequencyClass(category, count)">
							<pre
								class="freq"
								:class="(count > categoryLimit(category)) && 'fx'"
								x-text="frequencyText(category, count, categoryLimit(category))"
							></pre>
						</li>
					</template>
				</ul>
			</section>
		</main>

		<script type="module" src="/src/main.ts"></script>
	</body>
</html>
